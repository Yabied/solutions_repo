{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. Task 1. Theoretical Foundation Begin by deriving the governing equations of motion from fundamental principles. This involves solving a basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions. The horizontal and vertical components of motion can be expressed as: \\[x(t) = v_0 \\cos(\\theta) t \\] \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - $v_0 $ is the initial velocity, $\\theta $ is the angle of projection, $g $ is the acceleration due to gravity. The time of flight is obtained by solving for when $y = 0 $: \\[t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range is given by: \\[R = v_0 \\cos(\\theta) \\times t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 2. Analysis of the Range Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship. Observations: The range is maximized when $\\theta = 45^\\circ $. Increasing $v_0 $ results in a larger range. Increasing $g $ reduces the range. 3. Practical Applications Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance. Consider the effect of wind resistance and varying gravity, such as on different planets or celestial bodies. 4. Implementation Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions. A simple Python implementation using matplotlib and numpy can be used to generate plots demonstrating these principles. import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) angles = np.linspace(0, 90, 100) # angles from 0 to 90 degrees ranges = (v0**2 * np.sin(np.radians(2*angles))) / g plt.plot(angles, ranges) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Angle\") plt.grid() plt.show() This simulation can be extended to account for varying initial conditions and external factors such as air resistance. Conclusion By systematically analyzing the relationship between the angle of projection and the range of a projectile, we uncover key insights that are not only fundamental to physics but also widely applicable in engineering, sports science, and aerospace technology. Computational modeling further enhances our ability to visualize and understand these relationships, providing a powerful tool for both theoretical and practical applications. that","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Begin by deriving the governing equations of motion from fundamental principles. This involves solving a basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions. The horizontal and vertical components of motion can be expressed as: \\[x(t) = v_0 \\cos(\\theta) t \\] \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: - $v_0 $ is the initial velocity, $\\theta $ is the angle of projection, $g $ is the acceleration due to gravity. The time of flight is obtained by solving for when $y = 0 $: \\[t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range is given by: \\[R = v_0 \\cos(\\theta) \\times t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship. Observations: The range is maximized when $\\theta = 45^\\circ $. Increasing $v_0 $ results in a larger range. Increasing $g $ reduces the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance. Consider the effect of wind resistance and varying gravity, such as on different planets or celestial bodies.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions. A simple Python implementation using matplotlib and numpy can be used to generate plots demonstrating these principles. import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravitational acceleration (m/s^2) v0 = 20 # initial velocity (m/s) angles = np.linspace(0, 90, 100) # angles from 0 to 90 degrees ranges = (v0**2 * np.sin(np.radians(2*angles))) / g plt.plot(angles, ranges) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Angle\") plt.grid() plt.show() This simulation can be extended to account for varying initial conditions and external factors such as air resistance.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"By systematically analyzing the relationship between the angle of projection and the range of a projectile, we uncover key insights that are not only fundamental to physics but also widely applicable in engineering, sports science, and aerospace technology. Computational modeling further enhances our ability to visualize and understand these relationships, providing a powerful tool for both theoretical and practical applications. that","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem Great project! The forced damped pendulum is a classic system that opens up so many fascinating directions, from resonance to chaos theory. To get you started, here\u2019s a structured plan you can follow for your report and Python notebook: \ud83d\udcd8 Markdown Document Structure 1. Theoretical Foundation \ud83d\udccc Governing Equation: The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) = angular displacement - \\(\\gamma\\) = damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) = natural frequency - \\(A\\) = driving amplitude - \\(\\omega\\) = driving frequency \ud83e\udde0 Small-Angle Approximation: For small angles, \\(\\sin(\\theta) \\approx \\theta\\) : \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] Solve this using methods for linear ODEs (e.g., undetermined coefficients or Laplace transforms) and identify resonance conditions when \\(\\omega \\approx \\omega_0\\) . 2. Analysis of Dynamics Use simulations to explore how varying: \\(\\gamma\\) (damping) \\(A\\) (amplitude) \\(\\omega\\) (driving frequency) affect motion. Discuss: Regular periodic motion Quasiperiodicity Onset of chaos (e.g., using Lyapunov exponents or visual markers) 3. Practical Applications Relate the pendulum to: - Energy harvesting systems (resonant-based harvesting) - Suspension bridges (resonance-related failures) - Driven RLC circuits (electrical analog) 4. Computational Model (Python) Include: - Numerical solver (e.g., scipy.integrate.solve_ivp ) - Time series and phase space plots - Poincar\u00e9 sections: sample the state at regular intervals - Bifurcation diagram: sweep parameters and plot long-term behavior \ud83d\udc0d Python Code Outline import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum parameters gamma = 0.2 # Damping coefficient omega_0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2/3 # Driving frequency # ODE system def pendulum(t, y): theta, omega_p = y dtheta_dt = omega_p domega_dt = -gamma * omega_p - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions and time span y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Solve ODE sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plotting plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.show() From here, you can: - Add sliders for interactive control (e.g., with ipywidgets ) - Generate Poincar\u00e9 sections: theta and omega sampled at integer multiples of driving period \\( T = \\frac{2\\pi}{\\omega} \\) - Create bifurcation plots by sweeping A or omega h","title":"Problem Great project! The forced damped pendulum is a classic system that opens up so many fascinating directions, from resonance to chaos theory."},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-great-project-the-forced-damped-pendulum-is-a-classic-system-that-opens-up-so-many-fascinating-directions-from-resonance-to-chaos-theory","text":"To get you started, here\u2019s a structured plan you can follow for your report and Python notebook:","title":"Problem Great project! The forced damped pendulum is a classic system that opens up so many fascinating directions, from resonance to chaos theory."},{"location":"1%20Physics/1%20Mechanics/Problem_2/#markdown-document-structure","text":"","title":"\ud83d\udcd8 Markdown Document Structure"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) = angular displacement - \\(\\gamma\\) = damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) = natural frequency - \\(A\\) = driving amplitude - \\(\\omega\\) = driving frequency","title":"\ud83d\udccc Governing Equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, \\(\\sin(\\theta) \\approx \\theta\\) : \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] Solve this using methods for linear ODEs (e.g., undetermined coefficients or Laplace transforms) and identify resonance conditions when \\(\\omega \\approx \\omega_0\\) .","title":"\ud83e\udde0 Small-Angle Approximation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Use simulations to explore how varying: \\(\\gamma\\) (damping) \\(A\\) (amplitude) \\(\\omega\\) (driving frequency) affect motion. Discuss: Regular periodic motion Quasiperiodicity Onset of chaos (e.g., using Lyapunov exponents or visual markers)","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Relate the pendulum to: - Energy harvesting systems (resonant-based harvesting) - Suspension bridges (resonance-related failures) - Driven RLC circuits (electrical analog)","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computational-model-python","text":"Include: - Numerical solver (e.g., scipy.integrate.solve_ivp ) - Time series and phase space plots - Poincar\u00e9 sections: sample the state at regular intervals - Bifurcation diagram: sweep parameters and plot long-term behavior","title":"4. Computational Model (Python)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-outline","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Pendulum parameters gamma = 0.2 # Damping coefficient omega_0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2/3 # Driving frequency # ODE system def pendulum(t, y): theta, omega_p = y dtheta_dt = omega_p domega_dt = -gamma * omega_p - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions and time span y0 = [0.1, 0.0] t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Solve ODE sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plotting plt.plot(sol.t, sol.y[0]) plt.xlabel('Time') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.show() From here, you can: - Add sliders for interactive control (e.g., with ipywidgets ) - Generate Poincar\u00e9 sections: theta and omega sampled at integer multiples of driving period \\( T = \\frac{2\\pi}{\\omega} \\) - Create bifurcation plots by sweeping A or omega h","title":"\ud83d\udc0d Python Code Outline"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2Great! Here's how we can structure your Markdown document and Python notebook to cover everything: \ud83d\udcc4 Escape Velocities and Cosmic Velocities \ud83d\ude80 Motivation Escape and cosmic velocities form the foundation of astrodynamics and space mission planning. They determine the energy required to overcome gravitational bounds, whether to maintain orbit, leave a planet, or even escape a solar system. \ud83c\udf0c Definitions 1. First Cosmic Velocity (Orbital Velocity) Minimum velocity needed to stay in a stable circular orbit just above a celestial body\u2019s surface. $ v_1 = \\sqrt{\\frac{GM}{R}} ) 2. Second Cosmic Velocity (Escape Velocity) Minimum velocity to completely escape the gravitational field without further propulsion. $ v_2 = \\sqrt{2GM/R} ) 3. Third Cosmic Velocity (Solar System Escape Velocity) Minimum velocity to escape the gravitational influence of the Sun (or central star) from a planet\u2019s orbit. Requires considering both the planet\u2019s orbital speed and the Sun\u2019s pull. \ud83e\uddee Mathematical Derivations Let: - $ G ) = gravitational constant - $ M ) = mass of the celestial body - $ R ) = radius from center of mass Key Insight : - $ v_2 = \\sqrt{2} \\cdot v_1 ) - $ v_3 ) is derived from energy conservation involving both planet and solar system dynamics. \ud83c\udf0d Comparative Calculations We'll calculate and visualize the three velocities for: Earth Mars Jupiter Python Snippet Preview: import matplotlib.pyplot as plt import numpy as np # Constants G = 6.67430e-11 # m\u00b3/kg/s\u00b2 # Celestial bodies data: [mass (kg), radius (m), orbital radius (m) around Sun] bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.898e27, 6.9911e7, 7.785e11] } def velocities(mass, radius, orbit_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2 * G * mass / radius) v_orbit_sun = np.sqrt(G * 1.989e30 / orbit_radius) # Sun mass = 1.989e30 kg v3 = v_orbit_sun + v2 return v1, v2, v3 results = {body: velocities(*data) for body, data in bodies.items()} # Visualization labels = list(results.keys()) v1_vals = [results[b][0] for b in labels] v2_vals = [results[b][1] for b in labels] v3_vals = [results[b][2] for b in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x, v2_vals, width, label='2nd Cosmic Velocity') plt.bar(x + width, v3_vals, width, label='3rd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Different Planets') plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83d\udef0\ufe0f Application in Space Exploration First Cosmic Velocity : Used for satellite launches into Earth orbit (LEO, MEO, GEO). Second Cosmic Velocity : Launching missions like Voyager, Apollo, Mars Rovers. Third Cosmic Velocity : Needed for leaving the Solar System \u2013 critical for interstellar probes. \ud83d\udce6 Deliverables You\u2019ll get: - A Markdown document ( cosmic_velocities.md ) - A Python notebook ( cosmic_velocities.ipynb ) with: - All formulas and derivations - Calculations - Visualizations","title":"Problem 2Great! Here's how we can structure your Markdown document and Python notebook to cover everything:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2great-heres-how-we-can-structure-your-markdown-document-and-python-notebook-to-cover-everything","text":"","title":"Problem 2Great! Here's how we can structure your Markdown document and Python notebook to cover everything:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"\ud83d\udcc4 Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape and cosmic velocities form the foundation of astrodynamics and space mission planning. They determine the energy required to overcome gravitational bounds, whether to maintain orbit, leave a planet, or even escape a solar system.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"\ud83c\udf0c Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"Minimum velocity needed to stay in a stable circular orbit just above a celestial body\u2019s surface. $ v_1 = \\sqrt{\\frac{GM}{R}} )","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"Minimum velocity to completely escape the gravitational field without further propulsion. $ v_2 = \\sqrt{2GM/R} )","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-solar-system-escape-velocity","text":"Minimum velocity to escape the gravitational influence of the Sun (or central star) from a planet\u2019s orbit. Requires considering both the planet\u2019s orbital speed and the Sun\u2019s pull.","title":"3. Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"Let: - $ G ) = gravitational constant - $ M ) = mass of the celestial body - $ R ) = radius from center of mass Key Insight : - $ v_2 = \\sqrt{2} \\cdot v_1 ) - $ v_3 ) is derived from energy conservation involving both planet and solar system dynamics.","title":"\ud83e\uddee Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparative-calculations","text":"We'll calculate and visualize the three velocities for: Earth Mars Jupiter","title":"\ud83c\udf0d Comparative Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-snippet-preview","text":"import matplotlib.pyplot as plt import numpy as np # Constants G = 6.67430e-11 # m\u00b3/kg/s\u00b2 # Celestial bodies data: [mass (kg), radius (m), orbital radius (m) around Sun] bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.898e27, 6.9911e7, 7.785e11] } def velocities(mass, radius, orbit_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2 * G * mass / radius) v_orbit_sun = np.sqrt(G * 1.989e30 / orbit_radius) # Sun mass = 1.989e30 kg v3 = v_orbit_sun + v2 return v1, v2, v3 results = {body: velocities(*data) for body, data in bodies.items()} # Visualization labels = list(results.keys()) v1_vals = [results[b][0] for b in labels] v2_vals = [results[b][1] for b in labels] v3_vals = [results[b][2] for b in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x, v2_vals, width, label='2nd Cosmic Velocity') plt.bar(x + width, v3_vals, width, label='3rd Cosmic Velocity') plt.xticks(x, labels) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Different Planets') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Snippet Preview:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#application-in-space-exploration","text":"First Cosmic Velocity : Used for satellite launches into Earth orbit (LEO, MEO, GEO). Second Cosmic Velocity : Launching missions like Voyager, Apollo, Mars Rovers. Third Cosmic Velocity : Needed for leaving the Solar System \u2013 critical for interstellar probes.","title":"\ud83d\udef0\ufe0f Application in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"You\u2019ll get: - A Markdown document ( cosmic_velocities.md ) - A Python notebook ( cosmic_velocities.ipynb ) with: - All formulas and derivations - Calculations - Visualizations","title":"\ud83d\udce6 Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Great! That\u2019s an awesome project\u2014it ties together core ideas in orbital mechanics with practical simulations. Here's how you can structure your Markdown document and Python code to meet the deliverables: \ud83d\udcd8 Trajectories of a Freely Released Payload Near Earth \ud83d\ude80 Motivation When a payload is released from a rocket near Earth, its path depends heavily on the initial velocity and release altitude. This investigation reveals how gravitational forces and motion interact to produce diverse trajectories\u2014ranging from elliptical to hyperbolic and parabolic. These principles are central to mission design, reentry strategies, and interplanetary transfers. $$ \ud83d\udcd0 Theoretical Background Newton\u2019s Law of Gravitation: $$ F = \\frac{GMm}{r^2} ] Equation of Motion in a Central Gravitational Field: $$ \\ddot{\\vec{r}} = -\\frac{GM}{r^3} \\vec{r} ] Where: - ( G $ is the gravitational constant, - ( M $ is Earth's mass, - ( r $ is the distance from Earth\u2019s center, - ( \\vec{r} $ is the position vector. Total Mechanical Energy: $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} ] - If ( E < 0 $: Elliptical orbit - If ( E = 0 $: Parabolic trajectory - If ( E > 0 $: Hyperbolic escape \ud83e\uddee Numerical Simulation (Python) We\u2019ll implement a basic gravitational simulator using the Velocity Verlet integration method. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Earth mass [kg] R_earth = 6.371e6 # Earth radius [m] # Initial conditions r0 = np.array([R_earth + 300e3, 0]) # 300 km altitude v0 = np.array([0, 7600]) # velocity in m/s (adjust for scenario) # Time parameters dt = 1 # time step [s] t_max = 10000 # total simulation time [s] # Simulation arrays r = r0.copy() v = v0.copy() positions = [r.copy()] # Velocity Verlet integration for _ in range(int(t_max / dt)): r_norm = np.linalg.norm(r) a = -G * M * r / r_norm**3 r_new = r + v * dt + 0.5 * a * dt**2 a_new = -G * M * r_new / np.linalg.norm(r_new)**3 v += 0.5 * (a + a_new) * dt r = r_new positions.append(r.copy()) positions = np.array(positions) # Plotting plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0] / 1e3, positions[:, 1] / 1e3, label=\"Payload Path\") circle = plt.Circle((0, 0), R_earth / 1e3, color='b', label=\"Earth\") plt.gca().add_patch(circle) plt.xlabel(\"x [km]\") plt.ylabel(\"y [km]\") plt.axis('equal') plt.grid(True) plt.legend() plt.title(\"Trajectory of Released Payload Near Earth\") plt.show() \ud83c\udf0d Discussion: Trajectories and Their Implications Scenario Initial Speed Energy Trajectory Application Reentry < Orbital Velocity ( E < 0 $ Suborbital/elliptical Capsule return, deorbit Stable Orbit Orbital Velocity ( E < 0 $ Elliptical/Circular Satellite insertion Escape > Escape Velocity ( E > 0 $ Hyperbolic Interplanetary missions \ud83d\udcca Extensions and Visualization Ideas Overlay Earth\u2019s atmosphere and geostationary orbit. Animate the trajectory for different initial speeds/angles. Compute escape velocity at varying altitudes. --","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83d\udcd8 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a rocket near Earth, its path depends heavily on the initial velocity and release altitude. This investigation reveals how gravitational forces and motion interact to produce diverse trajectories\u2014ranging from elliptical to hyperbolic and parabolic. These principles are central to mission design, reentry strategies, and interplanetary transfers. $$","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"","title":"\ud83d\udcd0 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"$$ F = \\frac{GMm}{r^2} ]","title":"Newton\u2019s Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equation-of-motion-in-a-central-gravitational-field","text":"$$ \\ddot{\\vec{r}} = -\\frac{GM}{r^3} \\vec{r} ] Where: - ( G $ is the gravitational constant, - ( M $ is Earth's mass, - ( r $ is the distance from Earth\u2019s center, - ( \\vec{r} $ is the position vector.","title":"Equation of Motion in a Central Gravitational Field:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#total-mechanical-energy","text":"$$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} ] - If ( E < 0 $: Elliptical orbit - If ( E = 0 $: Parabolic trajectory - If ( E > 0 $: Hyperbolic escape","title":"Total Mechanical Energy:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-python","text":"We\u2019ll implement a basic gravitational simulator using the Velocity Verlet integration method. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Earth mass [kg] R_earth = 6.371e6 # Earth radius [m] # Initial conditions r0 = np.array([R_earth + 300e3, 0]) # 300 km altitude v0 = np.array([0, 7600]) # velocity in m/s (adjust for scenario) # Time parameters dt = 1 # time step [s] t_max = 10000 # total simulation time [s] # Simulation arrays r = r0.copy() v = v0.copy() positions = [r.copy()] # Velocity Verlet integration for _ in range(int(t_max / dt)): r_norm = np.linalg.norm(r) a = -G * M * r / r_norm**3 r_new = r + v * dt + 0.5 * a * dt**2 a_new = -G * M * r_new / np.linalg.norm(r_new)**3 v += 0.5 * (a + a_new) * dt r = r_new positions.append(r.copy()) positions = np.array(positions) # Plotting plt.figure(figsize=(8, 8)) plt.plot(positions[:, 0] / 1e3, positions[:, 1] / 1e3, label=\"Payload Path\") circle = plt.Circle((0, 0), R_earth / 1e3, color='b', label=\"Earth\") plt.gca().add_patch(circle) plt.xlabel(\"x [km]\") plt.ylabel(\"y [km]\") plt.axis('equal') plt.grid(True) plt.legend() plt.title(\"Trajectory of Released Payload Near Earth\") plt.show()","title":"\ud83e\uddee Numerical Simulation (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion-trajectories-and-their-implications","text":"Scenario Initial Speed Energy Trajectory Application Reentry < Orbital Velocity ( E < 0 $ Suborbital/elliptical Capsule return, deorbit Stable Orbit Orbital Velocity ( E < 0 $ Elliptical/Circular Satellite insertion Escape > Escape Velocity ( E > 0 $ Hyperbolic Interplanetary missions","title":"\ud83c\udf0d Discussion: Trajectories and Their Implications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#extensions-and-visualization-ideas","text":"Overlay Earth\u2019s atmosphere and geostationary orbit. Animate the trajectory for different initial speeds/angles. Compute escape velocity at varying altitudes. --","title":"\ud83d\udcca Extensions and Visualization Ideas"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}